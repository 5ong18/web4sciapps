TITLE: Using Web Frameworks to Ease the Development of Web Applications for Computational Science
AUTHOR: Anders Johansen at Simula
AUTHOR: Hans Petter Langtangen at Simula and UiO
DATE: today

TOC: on

Web2py links:

 * "5-part tutorial": "https://github.com/mjhea0/web2py"
 * URL: "http://www.youtube.com/watch?v=BXzqmHx6edY"
 * URL: "http://www.web2py.com/"
 * URL: "http://web2py.com/book"

======= Web frameworks =======

Computational scientists may want to offer their applications through
a web interface. Basically, this means that users can set input data
to the application on a web page, then click *Compute*, and back
comes a new web page with the results of the computations.
Such web applications can be made from scratch using CGI scripts
in (e.g.) Python, but the code quickly gets longer and more involved as
the complexity of the web interface grows. Nowadays, most web applications
are created with the aid of *web frameworks*, which are software
packages that simplify the programming task. The downside of
web frameworks is that there is a significant amount of steps and
details to learn before your first simple demo application works.
The upside is that much more advanced applications are within reach
without much extra work.

We shall explore two web frameworks: the very popular "Django framework": "https://www.djangoproject.com/" and the more high-level and easy-to-use framework
"Flask": "http://flask.pocoo.org/". In addition, our examples are also
implemented in the "web2py": "http://www.web2py.com/" framework.
#Its slogan says "Django makes it easier to build better Web apps more quickly and with less code".
The primary advantage of Django
over other web frameworks is the rich set of documentation and
examples. Googling for "Django tutorials" gives lots of hits including
a  list of "web tutorials": "https://code.djangoproject.com/wiki/Tutorials"
and a list of "YouTube videos": "http://www.youtube.com/playlist?list=PL385A53B00B8B158E". There is also an electronic "Django book": "http://www.djangobook.com/en/2.0/". The primary documentation of Flask is the web site URL: "http://flask.pocoo.org/"

The problem for a computational scientist, who wants to enable
mathematical calculations through the web, is that most of
the introductory examples on utilizing a particular
web framework address web applications
of very different nature, e.g., blogs. Therefore, we have made an
alternative introduction which explains, in the simplest possible way,
how web frameworks can be used to

 o set up a web page with input data to your application,
 o run the application, and
 o set up a web page with the results of the computations.

To work with Django, you need to know about Python packages and modules
as well as Python classes. With Flask it is enough to be familiar with
functions and modules, though knowledge of decorators might an advantage.


===== The MVC pattern =====

The MVC pattern stands for Model-View-Controller and is a way of
separating the user's interaction with an application from the inner
workings of the application. The "Wikipedia definition of the MVC pattern": "http://en.wikipedia.org/wiki/MVC_Pattern" gives a very high-level
explanation of what the model, view, and controller do and acknowledges
the fact that different web frameworks interpret the three components
differently. Any web application works with a set of data and needs
a user interface for communicating the data with the user. The classical
MVC pattern introduces

 * the model to hold the data
 * the view to display data
 * the controller to move data by gluing the model and the view.

For applications performing mathematical computations we find it
convenient to explicitly introduce a fourth component that we call
*compute* where the mathematical computations are encapsulated.  With
the MVC pattern and the compute component we have a clear separation
between data (model), the way data is presented (view), the
computations (compute), and the way these components communicate
(controller). In a small program such a separation may look as
overkill, but it pays off in more complicated applications. More
importantly, the concepts of the MVC pattern saturates the modules and
files of web frameworks so one really needs to adapt to the MVC way of
thinking.

With Flask we are free to interpret the MVC pattern the way we want,
while Django by convention forces its interpretation of view and
model upon us. In fact, Django generates files with names
`views.py` and `models.py` so
it is necessary to have an understanding of what a model and a view
means in a Django context. Here we shall employ the following
convention which is compatible with Django and easy to work with
in Flask too:

 * the model contains the data (often only the input data) of the application,
 * the view controls the user interface that handles input and output data,
   and also calls to functionality that computes the output given the input.

The controller in Django lies both in the view and in configuration
files, while with Flask we make the controller more explicit
in a file. Moreover, the view is also intimitely connected to
a *template* file specifying the HTML in the generated web pages.

Forthcoming examples will illustrate how a scientific application is
split to meet the requirements of the MVC software design pattern.

===== A very simple application =====

## Define Mako variable for path to source code
<%
src_path = '../../../src/'
app_path = src_path + 'hw/orig'
%>

We shall start with the simplest possible application,
a "scientific hello world program", where the
task is to read a number of write out "Hello, World!" followed by
the sine of the number. This application has one input variable and
a line of text as output.

Our first implementation reads the input from the command
line and writes the results to the terminal window:

@@@CODE ${app_path}/hw.py

The task of the web version of this program is to read `r`
variable from a web page, compute the sine,
and write out a new web page with the resulting text.

===== Application of the MVC pattern =====

## Define Mako variable for path to source code
<%
app_path = src_path + 'hw/mvc'
%>

Before thinking of a web application, we first *refactor* our program
such that it fits with the classical MVC pattern and a compute component.
The refactoring does not change the functionality of the code, it
just distributes the original statements in functions and modules.
Here we create four modules: `model`, `view`,
`compute`, and `controller`.

 * The `compute` module contains a function `compute(r)` that performs
   the mathematics and returns the value of `s`.
 * The `model` module holds the input data, here `r`.
 * The `view` module has two functions, one for reading input data,
   `get_input`,
   and one for presenting the output, `present_output`.
   The later takes the input, calls `compute` functionalty, and
   generates the output.
 * The `controller` module initializes model's data from the view
   and calls the view to present the output.

The `model.py` file contains the `r` variable, which must
be declared with a default value in order to create the data object:

@@@CODE ${app_path}/model.py

The `view.py` file is restricted to the communication with the user and reads

@@@CODE ${app_path}/view.py

The mathematics is encapsulated in `compute.py`:

@@@CODE ${app_path}/compute.py

Finally, `controller.py` glues the model and the view:

@@@CODE ${app_path}/controller.py

Let us try our refactored code:

!bc sys
Terminal> python controller.py 1.2
Hello, World! sin(1.2)=0.932039
!ec

Our goal is to create a web interface to our scientific hello world
program such that we can fill in the number `r` in a text field, click a
*Compute* button and get back a new web page with the output text
shown above: "Hello, World! sin(r)=s".

======= Making a Flask application =======

Not much code or configuration is needed to make a Flask application.
Actually one short file is enough. For this file to work you need to
install Flask and some corresponding packages. This is easiest
performed by

!bc sys
Terminal> sudo pip install Flask
Terminal> sudo pip install WTForms
!ec
You can add `--upgrade` to upgrade a previous installation.

===== Programming the Flask application =====

We want our input page to feature in text field where the user can
write the value of `r`, see Figure ref{wf:hw1:flask:fig:input}.
By clicking *equals*
we compute the corresponding `s` and write out the result page
seen in Figure ref{wf:hw1:flask:fig:result}.

FIGURE: [fig/hw1_flask_input, width=400] The input page. label{wf:hw1:flask:fig:input}

FIGURE: [fig/hw1_flask_output, width=400] The output page. label{wf:hw1:flask:fig:result}

## Define Mako variable for path to source code
<%
app_path = '../apps/hw/hw1_flask'
%>

Flask does not require us to use the MVC pattern so there is actually
no need to split the original program into `model.py`, `view.py`,
`controller.py`, and `compute.py` as already explained.  First we make
a `controller.py` file where the view, the model, and the controller
parts are within the same part. Later, we split the view, model, and
controller into three files for illustration. The `compute` component
is always in a separate files as we like to encapsulate the
computations completely from user interfaces.

The view that the user sees is determined by
HTML templates in a subdirectory `templates`, and consequently
we name the template files `view*.html`.
The model and other parts of the view concept are just parts of
the `controller.py` file:

[[[Remaining:

 * copy v1 and v2 to github, make v3 with split files
 * copy/make Django apps for hw
 * Make Django apps for vib
 * introduce data_items list and show how apps can be generated
 * apply generated apps to simviz (make py simviz too and describe that)

@@@CODE ${app_path}/controller.py
We collect all files associated with a Flask application in a directory,
here called `hw1_flask`.

The web application is the `app` object of class `Flask` initialized
as shown. The model is a special Flask class derived from `Form`
where the data are listed as static class attributes and initialized
by various form field objects from the `wtforms` package.
These form fields correspond to HTML forms in the input page.
For the `r` variable we apply `FloatField` since it is a floating-point
variable. A default validator, here checking that the user supplies
a real number, is easily included.

The view, controlling how the user interacts with the data, consists
an URL and corresponding function to call when this is invoked URL.
The function name is here `index` (corresponding to the standard
`index.html` page that is the main page of a URL) and the
decorator `@app.route('/hw1', ...)` maps the URL
`http://127.0.0.1:5000/hw1` to a call to `index`.
The `methods` argument must be as shown to allow the user to communicate
with the web page.

The `index` function first makes a form object based on the data in
the model, here class `InputForm`. Then there are two possibilities:
either the user has provided data in the HTML form or the user is
to be offered an input form. In the former case, `request.method`
equals `'POST'` and we can extract the numerical value of `r`
from the `form` object, `form.r.data`, call up our mathematical
computations, and make a web page with the result.
In the latter case, we make an input page as displayed in
Figure ref{wf:hw1:flask:fig:input}.

Making a web page with Flask is conveniently done through an HTML
template. Since the output page is simplest we display the
`view_output.html` template first:

@@@CODE ${app_path}/templates/view_output.html

Keyword arguments sent to `render_template` are available in the
HTML template. With the `form` object we extract the value of
`r` in the HTML code by `{{form.r.data}}`. Similarly, the value of `s`
is simply `{{s}}`.

The HTML template for the input page is slightly more complicated
as we need to use an HTML form:

@@@CODE ${app_path}/templates/view_input.html

All you have to do in order to run this web application is

!bc sys
Terminal> python controller.py
!ec

===== Equipping the input page with output results =====

Our application made two distinct pages for grabbing input from the
user and presenting the result. It is often more natural to add
the result to the input page. This is particularly the case in the present
web application, which is a kind of calculator. Figure ref{wf:hw2:flask:fig:result} shows what the user sees after clicking the *equals* button.

FIGURE: [fig/hw2_flask_output, width=400] The modified result page. label{wf:hw2:flask:fig:result}

To let the user stay within the same page, we create a new directory `hw2_flask`
for this modified Flask application and copy the files from the previous
`hw1_flask` directory.  The idea now is to make use of just one
template, in `templates/view.html`:

@@@CODE ${app_path}/templates/view.html

The form is identical to what we used in `view_input.html`, and the only
new thing is the value of `s`. We supply `s` as an object to the
`render_template` function and this object is available for
some programming in the HTML template. We can test on the value of `s`:
if it is `None`, we know that the computations are not performed and
`s` should not appear on the page, otherwise `s` holds the sine
value and we can write it out. The generated HTML code reads

!bc html
<form method=post action="">
  Hello, World! The sine of
  <input id="r" name="r" type="text" value="1.2">
  <input type=submit value=equals>

0.932039085967

</form>
!ec

The `index` function needs adjustments since we use the same
template for the input and the output page:

@@@CODE ${app_path}/controller.py fromto: # View@if __name
It is seen that if the user has given data, `s` is a `float`, otherwise
`s` is `None`. You are encouraged to test the application by running

!bc sys
Terminal> python controller.py
!ec
and loading `http://127.0.0.1:5000/hw2` into your browser.
A nice little exercise is to control the formatting of the result `s`.
To this end, you transform `s` to a string: `s = '%.5f' % s` before
sending it to `render_template`.

===== Troubleshooting =====

__Address already in use.__
You can easily kill the Flask application and restart it, but sometimes
you will get an error that the address is already in use.
To recover from this problem, run the `lsof` program to see which program
that applies the 5000 port (Flask runs its server on `http://127.0.0.1:5000`):

!bc sys
Terminal> lsof -i :5000
COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
python  48824  hpl    3u  IPv4 1128848      0t0  TCP ...
Terminal> kill -9 48824
!ec
The last command killed the `python` job that ran the test server and
you are ready to relaunch the Flask application.


======= Making a Django application =======

Django applies two concepts, *project* and *application*. The application,
or app for short,
is the program we want to run through a web interface. The project is
a Python package containing common settings and configurations for
a collection of apps. This means that before we can make a Django app,
we must to establish a Django project.

===== Installing Django =====

We recommend to
download and istall the latest official version from
URL: "http://www.djangoproject.com/download/". Pack out the tarfile, go
to the directory, and run `setup.py`:

!bc sys
Terminal> tar xvzf Django-1.5-tar.gz
Terminal> cd Django-1.5
Terminal> sudo python setup.py install
!ec
The version in this example, 1.5., may be different at the time you
follow these instructions.


===== Setting up a Django project =====

A Django project for managing a set of Django apps is
created by the command

!bc sys
Terminal> django-admin.py startproject django_project
!ec
The result is a directory `django_project` whose content can be explored
by some `ls` and `cd` commands:

!bc sys
Terminal> ls django_project
manage.py django_project
Terminal> cd django_project/django_project
Terminal> ls
__init__.py settings.py urls.py wsgi.py
!ec
The meaning of the generated files are briefly listed below.

   o The outer `django_project/` directory is just a container for your project. Its name does not matter to Django.

   o `manage.py` is a command-line utility that lets you interact with this Django project in various ways. You will typically run `manage.py` to launch a Django application.

   o The inner `django_project/` directory is a Python package for the Django project. Its name is used in import statements in Python code (e.g., `import django_project.settings`).

   o `django_project/__init__.py` is an empty file that just tells Python that this directory should be considered a Python package.

   o `django_project/settings.py` contains the settings and configurations for this Django project.

   o `django_project/urls.py` maps URLs to specific functions and thereby defines that actions that various URLs imply.

   o `django_project/wsgi.py` is not needed in our examples.

Django comes with a web server for developing and debugging applications.
The server is started by running

!bc sys
Terminal> python manage.py runserver
!ec
You will see that the server runs on the URL "http://127.0.0.1:8000/".
Load this URL into your browser to see a welcome message from Django,
meaning that the server is working.

Despite the fact that our web applications do not need a database, you
have to register a database with a Django project. To this end,
open the `django_project/settings.py` file in a text editor,
locate the `DATABASES` dictionary and make sure the following
code is there:

!bc pycod
import os

def relative2absolute_path(relative_path):
    """Return the absolute path correspodning to relative_path."""
    dir_of_this_file = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(dir_of_this_file, relative_path)

DATABASES = {
   'default' : {
      'ENGINE': 'django.db.backends.sqlite3',
      'NAME': relative2absolute_path('../database.db')
   }
}
!ec
The `settings.py` file needs absolute paths to files, while it is
more convenient for us to specify relative paths. Therefore,
we made a function that figures out the absolute path to the `settings.py`
file and then combines this absolute path with the relative path.
The location and name of the database file can be chosen as desired.
Note that one should not use `os.path.join` to create paths as Django
applies the forward slash between directories also on Windows.


===== Setting up a Django application =====

The next step is to create a Django app for our scientific hello
world program. We can place the app in any directory, but here we
utilize the following organization.
As neighbor to `django_project` we have
a directory `apps` containing our various scientific applications.
Under `apps` we create a directory `hw`
for the various versions of the scientific hello world applications:
`orig` for the original `hw.py` program, `mvc` for a split of this
program according to the original MVC pattern, `mvc_django` for
the MVC split according to the way Django requires,
and `hw1_django` for a first version of
the program with a Django-based web interface.

!bc sys
Terminal> mkdir hw
Terminal> cd hw
Terminal> mkdir orig mvc mvc_django
!ec
The file `hw.py` is moved to `orig` while `mvc` and `mvc_django` contain
their versions of the files `model.py`, `view.py`, `compute.py`,
and `controller.py`.

The `hw1_django` directory, containing the Django application, must be
made with
!bc sys
Terminal> python ../../django_project/manage.py startapp hw1_django
!ec
The command creates a directory `hw1_django` with the content

!bc sys
Terminal> cd hw1_django
Terminal> ls
__init__.py models.py tests.py views.py
!ec
The `__init__.py` file is empty and needed to ensure that the
Django application is a Python package. The other files are also
empty, but `models.py` and `views.py` will soon be filled with content.

At this point,
we need to register some information about our application in the
`django_project/settings.py` and `django_project/urls.py` files.

__Step 1: Add the app.__ Locate the `INSTALLED_APPS`
tuple in `settings.py` and add your Django application as a Python package:
directory `django`:

!bc pycod
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    ...
    'hw1_django',
)
!ec
However, Django will not be able to find the package `hw1_django`
unless we register the parent directory in `sys.path`:

!bc pycod
import sys
sys.path.insert(0, relative2absolute_path('../apps/hw'))
!ec
Note here that the relative path is given with respect to the
location of the `settings.py` script.

__Step 2: Adding a template directory.__
Second, make a subdirectory `templates` under `django`,

!bc sys
mkdir templates
!ec
and add the absolute path of this directory to the `TEMPLATE_DIRS` tuple:

!bc pycod
TEMPLATE_DIRS = (
    relative2absolute_path('../../apps/hw/django/templates'),
)
!ec
The `templates` directory will hold templates for the HTML code applied
in the web interfaces. The trailing comma is important (as this is
a tuple with only one element).

__Step 3: Defining the URL.__ We need to connect the Django app with
an URL, i.e., the address we write into the web browser to launch the
app. Our app will be associated with a Python function `index`
in the `views` module within the `hw1_django` package.
Say we want the corresponding URL to
be named `hw`. This is registered in the `django_project/urls.py` file
by

!bc pycod
urlpatterns = patterns('',
    url(r'^hw/', 'hw1_django.views.index'),
!ec
The first argument to the `url` function is a regular expression for
the URL and the second argument is the name of the function to call.
The name `index` resembles the `index.html` main page associated
with an URL, but any other name than `index` can be used.

===== Programming the Django application =====

## Define Mako variable for path to source code
<%
app_path = '../apps/hw/hw1_django'
%>

The Django application is about filling the files `views.py` and `models.py`
with content. The mathematical computations are performed in `compute.py`
so we copy this file from the `mvc` directory to the `hw1_django` directory
for convenience (we could alternatively add `../mvc` to `sys.path` such that
`import compute` would work from the `hw1_django` directory).

__The model.__ The `models.py` file contains the model which consists
of the data we need in the application, stored in Django's data types.
Our data consists of one number, called `r`, and `models.py` then
look like

@@@CODE ${app_path}/models.py
The `Input` class lists variables representing data as static class
attributes. The `django.db.models` module contains various classes
for different types of data, here we use `FloatField` to represent
a floating-point number (corresponding to a Python `float`).
The `InputForm` class has a the shown generic form across applications
if we by convention apply the name `Input` for the class holding the data.

__The view.__ The `views.py` file contains a function `index` which performs
the actions we want to perform when invoking
the URL ( here `http://127.0.0.1:8000/hw/`).
In addition, `views.py` has the `present_output` function from
the `view.py` file in the `mvc_django` directory.

@@@CODE ${app_path}/views.py

The `index` function deserves some explanation. It must take one
argument, usually called `request`. There are two modes in the function. Either
the user has provided input on the web page, which means that
`request.method` equals `'POST'`, or we show a new web page
with which the user is supposed to interact.

__Making the input page.__ The input consists of a web form with
one field where we can fill in our `r` variable. This page
is realized by the two central statements

!bc pycod
# Make info needed in the web form
form = InputForm()
# Make HTML code
render_to_response('hw1.html',
    {'form': form}, context_instance=RequestContext(request))
!ec
The `hw1.html` file resides in the `templates` subdirectory and contains
a template for the HTML code:

@@@CODE ${app_path}/templates/hw1.html
This is a *template file* because it contains instructions like
`{% csrf_token %}` and variables like `{{ form.r }}`. Django will
replace the former by some appropriate HTML statements, while the
latter simply extracts the numerical value of the variable `r` in
our form (specified in the `Input` class in `models.py`).
Typically, this `hw1.html` file
results in the HTML code

!bc html
<form method="post" action="">
<div style='display:none'>
<input type='hidden' name='csrfmiddlewaretoken'
value='oPWMuuy1gLlXm9GvUZINv49eVUYnux5Q' /></div>
    Hello, World! The sine of <input type="text" name="r" id="id_r" />
    <input type="submit" value="equals" />
</form>
!ec
Figure ref{wf:hw1:django:fig:input} shows how the input page looks like in the
web browser.

FIGURE: [fig/hw1_django_input, width=400] The input page. label{wf:hw1:django:fig:input}

__Making the results page.__
When then user has filled in a value in the text field on the input
page, the `index` function is called again and `request.method` equals
`'POST'`. A new form object is made, this time with user info (`request.POST`).
We can check that the form is valid and if so, proceed with
computations followed by presenting the results in a
new web page (see Figure ref{wf:hw1:django:fig:result}):

!bc pycod
def index(request):
    if request.method == 'POST':
        form = InputForm(request.POST)
        if form.is_valid():
            form = form.save(commit=False)
            return present_output(form)

def present_output(form):
    r = form.r
    s = compute(r)
    return HttpResponse('Hello, World! sin(%s)=%s' % (r, s))
!ec
The numerical value of `r` as given by the user is available as `form.r`.
Instead of using a template for the output page, which is natural to
do in more advanced cases, we here illustrate the possibility to
send raw HTML to the output page by returning an `HttpResponse`
object initialized by a string containing the desired HTML code.

FIGURE: [fig/hw1_django_output, width=400] The result page. label{wf:hw1:django:fig:result}

Launch this application by filling in the address `http://127.0.0.1:8000/hw/`
in your web browser (make sure the Django development server is running,
and if not, restart it by `python manage.py runserver`). Try to fill
in some number on the input page and view the output.
To show how easy it is to change the application, invoke the `views.py`
file in an editor and add some color to the output HTML code from
the `present_output` function:

!bc pycod
    return HttpResponse("""
<font color='blue'>Hello</font>, World!
sin(%s)=%s
"""% (r, s))
!ec
Go back to the input page, provide a new number, and observe how
the "Hello" word now has a blue color.

===== Equipping the input page with output results =====

## Define Mako variable for path to source code
<%
app_path = '../apps/hw/hw2_django'
%>

Instead of making a separate output page with the result, we can
simply add the sine value to the input page. This makes the user
feel that she interacts with the same page, as when operating a calculator.
The output page should then look as shown in Figure ref{wf:hw2:django:fig:result}.

FIGURE: [fig/hw2_django_output, width=400] The modified result page. label{wf:hw2:django:fig:result}

We need to make a new Django application, now called `hw2_django`.
Instead of running
`manage.py startapp hw2_django` we can simply copy the `hw1_django`
directory. We need, of course, to add information about this
new application in `settings.py` and `urls.py`.
In the former file we must have

!bc pycod
TEMPLATE_DIRS = (
    relative2absolute_path('../../apps/hw1_django/templates'),
    relative2absolute_path('../../apps/hw2_django/templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'hw1_django',
    'hw2_django',
)
!ec
In `urls.py` we add the URL `hw2` which is to call our `index` function
in the `views.py` file of the `hw2_django` app:

!bc pycod
urlpatterns = patterns('',
    url(r'^hw1/', 'hw1_django.views.index'),
    url(r'^hw2/', 'hw2_django.views.index'),
!ec

The `views.py` file changes a bit since we shall generate almost the same
web page on input and output. This makes the `present_output` function
unnatural, and everything is done within the `index` function:

@@@CODE ${app_path}/views.py  fromto: def index@

Note that the output variable `s` is computed within the `index`
function and defaults to `None`. The template file `hw2.html`
looks like

@@@CODE ${app_path}/templates/hw2.html
The difference from `hw1.html` is that we right after the *equals*
button write out the value of `s`. However, we make a test that
the value is only written if it is computed, here recognized by
being a non-empty string. The `s` in the template file
is substituted by value corresponding to the key `'s'` in the
dictionary we pass to the `render_to_response`. As seen,
we pass a string where `s` is formatted with five digits if `s`
is a float, i.e., if `s` is computed. Otherwise, `s` has the
default value `None` and we send an empty string to the template.



======= Generalizing the Flask application =======

The scientific hello world example shows how to work with one input
variable and one output variable. We can easily derive a solution for
a collection of input variables and some corresponding HTML code
as result. Multiple input variables are listed in the `InputForm`
class using different types for different forms (text field,
float field, integer field, check box field for boolean values, etc.).
The value of these variables will be available in a `form` object
for computation. It is then a matter of taking the output from the
computation and format the corresponding HTML code for presenting
the result.

===== Handling multiple input variables =====

We address the task of plotting the function $u(t)=Ae^{-bt}\sin (wt)$ for
$t\in [0,T]$. The web application must have fields for the numbers $A$,
$b$, $w$, and $T$, a *Compute* button, which then returns the fields
with a plot of $u(t)$ below.

## Define Mako variable for path to source code
<%
app_path = '../apps/vib/vib_flask'
%>

The `compute.py` module has a function for evaluating $u(t)$ and
a `compute` function for making the plot. The return value is
the name of the plot file, which should get a unique name every
time the `compute` function is called such that the browser cannot
reuse an already cached image. Flask applications must have all
extra files (CSS, images, etc.) in a subdirectory `static`.

@@@CODE ${app_path}/compute.py

[[[The Flask application resides in a file `controller.py`.
The model part consists of the a subclass of `wtforms.Form`
containing all the input variables as field types (here `wtforms.FloatField`):

@@@CODE ${app_path}/controller.py fromto: # Model@# View

As seen, the field classes can take a `description` argument and
a `default` value.[[[[

exer:
Suppose our mathematical computations are done by
a function

!bc pycod
def compute_function(*args, **kwargs)
    ...
    return result
!ec
Given such a function, with specific positional and keyword arguments,
we can easily figure out the name of the arguments and the type
of the default values of the keyword arguments and in this way
extract knowledge about the input data. BUT: rendering result
is problem-dependent and must be hardcoded in the template?
Or let result.render return HTML which is inserted in view_template.html
to form view.html.

======= Exercises =======

===== Exercise: Add two numbers in a Flask app =====
label{wf:exer:flask:add2}
file=add2_flask.tar.gz

Make a Flask application that reads two numbers from a web page,
adds the numbers, and prints the sum in a new web page.
Package the Flask application directory in a tar file for easy testing
by others.

===== Exercise: Add two numbers in a Django app =====
label{wf:exer:django:add2}
file=add2_django.tar.gz

Make a Django application that reads two numbers from a web page,
adds the numbers, and prints the sum in a new web page.

Package
the application and a corresponding project in a tar file such
that anyone with Django installed can easily test the project.


===== Further reading =====

[hpl: should fine some good tutorials for scientists, or next best: some tutorials with not too uninteresting application for scientists...]

For more info, check the documentation at
URL: "http://docs.djangoproject.com".

