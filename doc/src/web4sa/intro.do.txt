======= Web frameworks =======

Computational scientists may want to offer their applications through
a web interface. Basically, this means that users can set input data
to the application on a web page, then click *Compute*, and back
comes a new web page with the results of the computations.
Such web applications can be made from scratch using CGI scripts
in (e.g.) Python, but the code quickly gets longer and more involved as
the complexity of the web interface grows. Nowadays, most web applications
are created with the aid of *web frameworks*, which are software
packages that simplify the programming task. The downside of
web frameworks is that there is a significant amount of steps and
details to learn before your first simple demo application works.
The upside is that much more advanced applications are within reach
without much extra work.

# #if TOPIC == 'Flask+Django'
We shall explore two web frameworks: the very popular "Django framework": "https://www.djangoproject.com/" and the more high-level and easy-to-use framework
"Flask": "http://flask.pocoo.org/". In addition, our examples are also
implemented in the "web2py": "http://www.web2py.com/" framework.
#Its slogan says "Django makes it easier to build better Web apps more quickly and with less code".
The primary advantage of Django
over other web frameworks is the rich set of documentation and
examples. Googling for "Django tutorials" gives lots of hits including
a  list of "web tutorials": "https://code.djangoproject.com/wiki/Tutorials"
and a list of "YouTube videos": "http://www.youtube.com/playlist?list=PL385A53B00B8B158E". There is also an electronic "Django book": "http://www.djangobook.com/en/2.0/". At the time of this writing, Flask is not
much documented beyond the "official web site": "http://flask.pocoo.org/" and the "WTForms Documentation": "http://wtforms.simplecodes.com/docs/0.6/index.html".
# #elif TOPIC == 'Flask'
We shall in the forthcoming text explore the very easy-to-use "Flask framework":
"http://flask.pocoo.org/".  At the time of this writing, Flask is not
much documented beyond the "official web site": "http://flask.pocoo.org/" and the "WTForms Documentation": "http://wtforms.simplecodes.com/docs/0.6/index.html".
# #elif TOPIC == 'Django'
We shall explore the very popular "Django framework": "https://www.djangoproject.com/" in the following.
The primary advantage of Django
over other web frameworks is the rich set of documentation and
examples. Googling for "Django tutorials" gives lots of hits including
a  list of "web tutorials": "https://code.djangoproject.com/wiki/Tutorials"
and a list of "YouTube videos": "http://www.youtube.com/playlist?list=PL385A53B00B8B158E". There is also an electronic "Django book": "http://www.djangobook.com/en/2.0/".
# #endif


The problem for a computational scientist, who wants to enable
mathematical calculations through the web, is that most of
the introductory examples on utilizing a particular
web framework address web applications
of very different nature, e.g., blogs. Therefore, we have made an
alternative introduction which explains, in the simplest possible way,
how web frameworks can be used to

 o set up a web page with input data to your application,
 o run the application, and
 o set up a web page with the results of the computations.

# #if TOPIC == 'Flask+Django'
To work with Django, you need to know about Python packages and modules
as well as Python classes. With Flask it is enough to be familiar with
functions and modules, though knowledge of classes and a bit of
decorators might be an advantage.
# #elif TOPIC == 'Flask'
Flask is very easy to work with and extensive Python knowledge is
not necessary. It is in fact enough to know about functions and
modules. Some knowledge of classes and a bit of decorators is
an advantage.
# #elif TOPIC == 'Django'
To work with Django, you need to know about Python packages and modules
as well as Python classes.
# #endif

!split
===== The MVC pattern =====

The MVC pattern stands for Model-View-Controller and is a way of
separating the user's interaction with an application from the inner
workings of the application. The "Wikipedia definition of the MVC pattern": "http://en.wikipedia.org/wiki/MVC_Pattern" gives a very high-level
explanation of what the model, view, and controller do and acknowledges
the fact that different web frameworks interpret the three components
differently. Any web application works with a set of data and needs
a user interface for communicating the data with the user. The classical
MVC pattern introduces

 * the model to hold the data
 * the view to display data
 * the controller to move data by gluing the model and the view.

For applications performing mathematical computations we find it
convenient to explicitly introduce a fourth component that we call
*compute* where the mathematical computations are encapsulated.  With
the MVC pattern and the compute component we have a clear separation
between data (model), the way data is presented (view), the
computations (compute), and the way these components communicate
(controller). In a small program such a separation may look as
overkill, but it pays off in more complicated applications. More
importantly, the concepts of the MVC pattern saturates the modules and
files of web frameworks so one really needs to adapt to the MVC way of
thinking.

Web frameworks often have their own way of interpreting the
model, view, and controller parts of the MVC pattern.
Here we shall employ an interpretation which is compatible with
what we need later on:

 * the model contains the data (often only the input data) of the application,
 * the view controls the user interface that handles input and output data,
   and also calls to functionality that computes the output given the input.

# #if TOPIC == 'Django'
Django generates files with names `views.py` and `models.py` so it is
necessary to have some idea what Django means with these terms.
The controller functionality in Django lies both in the `views.py` file and
in configuration
files (`settings.py` and `urls.py`). The view component of the application
consists both of the `views.py` file and template files used to create
the HTML code in the web pages.
# #elif TOPIC == 'Flask'
Flask does not force any MVC pattern on the programmer, but
the code needed to build web applications can easily be split into
model, view, and controller components, as will be shown later.
The view is also intimitely connected to
a *template* file specifying the HTML in the generated web pages.
# #elif TOPIC == 'Flask+Django'
Flask does not force any MVC pattern on the programmer, but
the code needed to build web applications can easily be split into
model, view, and controller components, as will be shown later.
Django, on the other hand, automatically generates application files with names
`views.py` and `models.py` so it is
necessary to have some idea what Django means with these terms.
The controller functionality in Django lies both in the `views.py` file and
in the configuration
files (`settings.py` and `urls.py`). The view component of the application
consists both of the `views.py` file and template files used to create
the HTML code in the web pages.
# #endif

Forthcoming examples will illustrate how a scientific application is
split to meet the requirements of the MVC software design pattern.

!split
===== A very simple application =====

## Define Mako variable for path to source code
<%
src_path = '../../../src/apps/'
app_path = src_path + 'hw/orig'
%>

We shall start with the simplest possible application,
a "scientific hello world program", where the
task is to read a number of write out "Hello, World!" followed by
the sine of the number. This application has one input variable and
a line of text as output.

Our first implementation reads the input from the command
line and writes the results to the terminal window:

@@@CODE ${app_path}/hw.py

The task of the web version of this program is to read `r`
variable from a web page, compute the sine,
and write out a new web page with the resulting text.

!split
===== Application of the MVC pattern =====
label{wf:hw:mvc}

## Define Mako variable for path to source code
<%
app_path = src_path + 'hw/mvc'
%>

Before thinking of a web application, we first *refactor* our program
such that it fits with the classical MVC pattern and a compute component.
The refactoring does not change the functionality of the code, it
just distributes the original statements in functions and modules.
Here we create four modules: `model`, `view`,
`compute`, and `controller`.

 * The `compute` module contains a function `compute(r)` that performs
   the mathematics and returns the value of `s`.
 * The `model` module holds the input data, here `r`.
 * The `view` module has two functions, one for reading input data,
   `get_input`,
   and one for presenting the output, `present_output`.
   The later takes the input, calls `compute` functionalty, and
   generates the output.
 * The `controller` module initializes model's data from the view
   and calls the view to present the output.

The `model.py` file contains the `r` variable, which must
be declared with a default value in order to create the data object:

@@@CODE ${app_path}/model.py

The `view.py` file is restricted to the communication with the user and reads

@@@CODE ${app_path}/view.py

The mathematics is encapsulated in `compute.py`:

@@@CODE ${app_path}/compute.py

Finally, `controller.py` glues the model and the view:

@@@CODE ${app_path}/controller.py

Let us try our refactored code:

!bc sys
Terminal> python controller.py 1.2
Hello, World! sin(1.2)=0.932039
!ec

Our goal is to create a web interface to our scientific hello world
program such that we can fill in the number `r` in a text field, click a
*Compute* button and get back a new web page with the output text
shown above: "Hello, World! sin(r)=s".
