
# Information about all exercises in the file web4sa.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.web4sa.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['add2.tar.gz'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wf:exer:add2',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Make a web application that reads two numbers from a web page,\nadds the numbers, and prints the sum in a new web page.\nPackage the necessary files that constitute the application\nin a tar file.',
  'title': 'Add two numbers',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wf:exer:vib3:demo',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Add a new argument `x_axis` to the `compute` function in the\n"`vib_flask3`": "https://github.com/hplgit/web4sciapps/tree/master/doc/src/web4sa/vib_flask3" application from Section\nref{wf:vib3:flask:autogen}. The `x_axis` argument measures the extent\nof the $x$ axis in the plots in terms of the number of standard\ndeviations (default may be 7).  Observe how the web interface\nautomatically adds the new argument and how the plots adapt!',
  'title': 'Extend the `vib3_flask` app',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib3_ext.tar.gz'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wf:exer:vib3:lists',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'In the "`vib_flask3`": "https://github.com/hplgit/web4sciapps/tree/master/doc/src/web4sa/vib_flask3"\napplication from Section ref{wf:vib3:flask:autogen},\nuse the `label` argument in the form field objects to add an\ninformation of the type of data that is to be supplied in the\ntext field. Extend the `model.py` file to also handle\nlists, tuples, and Numerical Python arrays. For these three\nnew data types, use a `TextField` object and run `eval`\non the text in the `view.py` file.\nA simple test is to extend the `compute` function with an\nargument `x_range` for the range of the $x$ axis, specified as\nan interval (2-list or 2-tuple).',
  'title': 'Equip the `vib3_flask` app with more data types',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['generate_flask.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Given a `compute` with a set of positional and keyword\narguments, the purpose of this exercise is to *automatically* generate the\nFlask files `model.py` and `view.py`. Use the Python `inspect`\nmodule, see Section ref{wf:vib3:flask:autogen}, to extract\nthe positional and keyword arguments in `compute`, and use this\ninformation to construct the relevant Python code. Assume as\nin Section ref{wf:vib3:flask:autogen} that the user provides\na file `view_results.html` for defining how the returned object\nfrom the `compute` function is to be rendered.\n\nTest the code generator on the `compute` function in the `vib1_flask`\napplication to check that the generated\n`model.py` and `view.py` files are correct.',
  'title': 'Auto-generate code from function signature',
  'type': 'Exercise',
  'type_visible': True}]