.. !split

.. _wf:vib:django:

Handling multiple input variables in Django
===========================================

We shall briefly demonstrate how to make the multi-variable input
application from the section :ref:`wf:vib:flask` in Django.
There are four float input variables: :math:`A`, :math:`b`, :math:`w`, and :math:`T`.
A function ``compute`` in the file ``compute.py`` makes
a plot of a function depending on these four parameters and returns
the name of the plot file. Our task is to define four input fields,
execute the ``compute`` function and show the input fields together with
the resulting plot, cf. Figures :ref:`wf:vib1:flask:fig:input`
and :ref:`wf:vib1:flask:fig:result`.

Programming the Django application  (2)
---------------------------------------




Any Django app needs a project, but here we reuse the project
we set up for the scientific hello world examples. We go to
``apps/vib`` and create the Django app


.. code-block:: console

        Terminal> python ../../django_project/manage.py startapp vib1_django

Then we

1. add ``sys.path.insert(0, relative2absolute_path('../../apps/vib'))``
   in ``settings.py``,

2. add ``relative2absolute_path('../../apps/vib/vib1_django/templates'),``
   to the ``TEMPLATE_DIRS`` tuple in ``settings.py``, and

3. add ``url(r'^vib1/', 'vib1_django.views.index')`` to the ``patterns``
   call in ``urls.py``.

.. index::
   single: Django; input forms


We can now invoke ``models.py`` to add form fields for the four
input variables:


.. code-block:: python

        from django.db import models
        from django.forms import ModelForm
        from math import pi
        
        class Input(models.Model):
            A = models.FloatField(
                verbose_name=' amplitude (m)', default=1.0)
            b = models.FloatField(
                verbose_name=' damping coefficient (kg/s)', default=0.0)
            w = models.FloatField(
                verbose_name=' frequency (1/s)', default=2*pi)
            T = models.FloatField(
                verbose_name=' time interval (s)', default=18)
        
        class InputForm(ModelForm):
            class Meta:
                model = Input

Note here that we can provide a more explanatory name than just
the variable name, e.g., ``' amplitude (m)'`` for ``A``. However,
Django will always capitalize these descriptions, so if one really
needs lower case names (e.g., to be compatible with mathematics),
one must start the text with a space. We also provide a default
value such that all fields have a value when the user sees
the page.


.. index::
   single: Django; index function


The ``views.py`` file looks as follows:


.. code-block:: python

        from django.shortcuts import render_to_response
        from django.template import RequestContext
        from django.http import HttpResponse
        from models import InputForm
        from compute import compute
        import os
        
        def index(request):
            os.chdir(os.path.dirname(__file__))
            result = None
            if request.method == 'POST':
                form = InputForm(request.POST)
                if form.is_valid():
                    form2 = form.save(commit=False)
                    result = compute(form2.A, form2.b, form2.w, form2.T)
                    result = result.replace('static/', '')
            else:
                form = InputForm()
        
            return render_to_response('vib1.html',
                    {'form': form,
                     'result': result,
                     }, context_instance=RequestContext(request))

Some remarks are necessary:

1. Doing an ``os.chdir`` to the current working directory is necessary
   as Django may be back in another working directory if you have
   tested other apps.

2. The ``form2`` object from ``form.save`` is the object we extract
   data from and send to ``compute``, but the original ``form``
   object is needed when making the HTML page through the template.

3. Images, media files, style sheets, javascript files, etc. must
   reside in a subdirectory ``static``. The specifications of the
   URL applies tools to find this ``static`` directory and then
   the ``static`` prefix in the ``result`` filename must be removed.

The template for rendering the page is listed next.


.. code-block:: html

        <form method=post action="">{% csrf_token %}
        <table>
          {% for field in form %}
            <tr>
            <td>{{ field.name }}</td>
            <td>{{ field }}</td>
            <td>{{ field.label }}</td>
            <td>{{ field.errors }}</td>
            <td></td>
            </tr>
          {% endfor %}
        </table>
        <p><input type=submit value=Compute></form></p>
        
        <p>
        {% if result != None %}
        {% load static %}
        <img src="{% get_static_prefix %}{{ result }}" width=500>
        {% endif %}
        </p>

The tricky part is the syntax for displaying *static content*, such as
the plot file made in the ``compute`` function.

User-provided validation  (2)
-----------------------------



Django has a series of methods available for user-provided validation
of form data. These are exemplified in the app ``vib2_django``, which
is an extension of the ``vib1_django`` app (with additional code, and
of course, registrations in ``settings.py`` and ``urls.py``).


.. index::
   single: Django; input validation


Checking that :math:`A>0` is easiest done with a built-in Django
validator:


.. code-block:: python

        class Input(models.Model):
            A = models.FloatField(
                verbose_name=' amplitude (m)', default=1.0,
                validators=[MinValueValidator(0)])


We can write our own validators, which are functions taking one parameter
as argument, a value, and raising a ``ValidationError`` if the value
is wrong. Checking that a value is inside an interval can first be
implemented by


.. code-block:: python

        def check_interval(value, min_value=None, max_value=None):
            """Validate that a value is inside an interval."""
            failure = False
            if min_value is not None:
                if value < min_value:
                    failure = True
            if max_value is not None:
                if value > max_value:
                    failure = True
            min_value = '-infty' if min_value is None else str(min_value)
            max_value =  'infty' if max_value is None else str(max_value)
            if failure:
                raise ValidationError(
                    'value=%s not in [%s, %s]' %
                    (value, min_value, max_value))

However, this function takes more than the value as argument. We therefore
need to wrap it by a function with ``value`` as the only argument:


.. code-block:: python

        import functools
        
        def interval(min_value=None, max_value=None):
            """Django-compatible interface to check_interval."""
            return functools.partial(
                check_interval, min_value=min_value, max_value=max_value)

Now, ``interval(0, 1)`` returns a function that takes ``value`` as its
only argument and checks if it is inside :math:`[0,1]`.
Such a function can be inserted in the ``validators`` list in
the field constructor, here to tell that :math:`b` must be in :math:`[0,\infty)`:


.. code-block:: python

        class Input(models.Model):
            ...
            b = models.FloatField(
                verbose_name=' damping coefficient (kg/s)', default=0.0,
                validators=[interval(0,None)])


A final example on custom validation is to avoid plotting more
than 30 periods of the oscillating function :math:`u`. This translates
to checking of :math:`T` is geater
than 30 periods, i.e., :math:`T>30\cdot 2\pi/w`. The task is done in
the ``InputForm`` class, where any method ``clean_T`` can do
validation and adjustment of the field name ``T``. The code goes
as follows:


.. code-block:: python

        class InputForm(ModelForm):
            class Meta:
                model = Input
        
            def clean_T(self):
                T = self.cleaned_data['T']
                w = self.cleaned_data['w']
                period = 2*pi/w
                if T > 30*period:
                    num_periods = int(round(T/period))
                    raise ValidationError(
                        'Cannot plot as much as %d periods! T < %.2f' %
                        (num_periods, 30*period))
                return T

We refer to the vast Django documentation for many other ways of
validating forms.

